
/*  A Bison parser, made from asm32.y with Bison version GNU Bison version 1.22
  */

#define YYBISON 1  /* Identify Bison output.  */

#define	PLSPLS	258
#define	MINUSMINUS	259
#define	REG	260
#define	REGR	261
#define	REGE	262
#define	REGHL	263
#define	REGIO	264
#define	ACCUM	265
#define	PC	266
#define	PIOP	267
#define	PIR	268
#define	PCSH	269
#define	DAUC	270
#define	IOC	271
#define	IBUF	272
#define	OBUF	273
#define	PDR	274
#define	PCW	275
#define	SYMBOL	276
#define	LABEL	277
#define	CONST	278
#define	FCONST	279
#define	CONST1	280
#define	CONST2	281
#define	ORG	282
#define	END	283
#define	ALIGN	284
#define	BYTE	285
#define	PAGE	286
#define	EQU	287
#define	LIST	288
#define	INT	289
#define	INT24	290
#define	FLOAT	291
#define	DA_FUN	292
#define	IF	293
#define	GOTO	294
#define	CALL	295
#define	RETURN	296
#define	IRETURN	297
#define	DO	298
#define	NOP	299
#define	CA_COND	300
#define	DA_COND	301
#define	IO_COND	302
#define	EQUEQU	303
#define	NOTEQU	304
#define	LE	305
#define	GE	306
#define	LSHIFT	307
#define	RSHIFT	308
#define	RROTATE	309
#define	LROTATE	310


#line 100 "asm32.y"
typedef union
{
	long value;
} YYSTYPE;
#line 142 "asm32.y"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <mem.h>
#include <alloc.h>
#include <io.h>
#include <fcntl.h>
#include <dir.h>
#include <process.h>
/* the following headers are only needed for creating Title[] */
#include <time.h>
#include <dos.h>
#include <sys\stat.h>
	
#define REV 0x02000000L		/* bit-reversed flag */
#define EXT 0x80000000L		/* 24-bit extended flag */
#define LOW 0x40000000L		/* 8-bit low-byte flag */
#define HIGH 0x20000000L	/* 8-bit high-byte flag */

long Org = 0L;			/* current address */
int Page_length = 63;
int Page_width = 80;
int List_type = 3;		/* main file & generated code */

#define MAX_DATA 	4096	/* MAX # program bytes */

#define MAX_SYMBOL	17	/* Max # chars in a SYMBOL */

#define UNDEFINED	0x80000000L	/* undefined SYMBOL value */

typedef struct Symbol {
	struct Symbol *next;
	char name[MAX_SYMBOL+1];
	int type;
	long value;
} Symbol;

/* temp pointers for SYMBOL definition (pipelined) */
Symbol *Last_symbol = 0;
Symbol *Symbol_def = 0;

/* prototypes for C functions */
void endit(void);
void yyerror(char *s);
void errormsg(char *s);
void error_symbol(char *msg, Symbol *s);
void warning(char *s);
void warn_symbol(char *msg, Symbol *s);
void fatal(char *s);
int yylex();
long dspfloat(float f);
long dspnegfloat(long f);
int getinput();
void list_address(long addr);
void list_data(long data, int offset, int size);
void prepare_list();
void prepare_list_line(int lineno, char *input, char flag);
void list_print();
void list_page(int omit_list);
void end_stmt();
void define_data(long value, int size);
void define_array(int n, long value, int size);
int hash(char *name);
Symbol *symbol(char *name);
void define_label(long value);
void symbol_init();
void undefine_symbols(int type);
long mem_ref(long reg, long incr);
long x_ref(long mem_ref);
long y_ref(long mem_ref);
long z_ref(long mem_ref);
void da_1(long fmt, long m, long f, long s, long da_dest, long x, long y, long z);
void da_5(long g, long da_dest, long y);
long goto_dest(long reg, long n);
void ca_0(long cond, long goto_dest);
void ca_3a(long m, long goto_dest);
void ca_4(long m, long h, long n);
void ca_5(long d, long h, long n);
long ca_6a(long f, long d, long s1, long s2);
void ca_6c(long f, long d, long n, long s);
void ca_7a(long t, long h, long n);
void ca_7b(long t, long h, long mem_ref);
void ca_7d(long t, long r, long mem_ref);
void ca_8(int type, long reg, long expr);

#ifndef YYLTYPE
typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;

#define YYLTYPE yyltype
#endif

#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	YYFINAL		408
#define	YYFLAG		-32768
#define	YYNTBASE	77

#define YYTRANSLATE(x) ((unsigned)(x) <= 310 ? yytranslate[x] : 118)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,    74,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,    71,     2,    76,     2,    70,    55,     2,    49,
    50,    68,    66,    75,    67,     2,    69,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,    52,    73,    58,
    48,    59,    51,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,    54,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,    53,     2,    72,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
    46,    47,    56,    57,    60,    61,    62,    63,    64,    65
};

#if YYDEBUG != 0
static const short yyprhs[] = {     0,
     0,     1,     4,     8,    10,    13,    16,    19,    22,    24,
    26,    29,    32,    35,    37,    40,    43,    46,    49,    52,
    57,    62,    67,    72,    73,    78,    79,    84,    85,    90,
    91,    96,    98,   101,   106,   109,   111,   115,   117,   119,
   123,   125,   127,   131,   133,   135,   139,   141,   143,   146,
   149,   151,   160,   167,   172,   185,   196,   205,   212,   219,
   230,   237,   244,   251,   258,   262,   266,   270,   272,   274,
   276,   278,   280,   282,   284,   286,   288,   290,   292,   294,
   297,   301,   305,   310,   312,   314,   319,   321,   323,   324,
   326,   328,   330,   332,   334,   340,   346,   352,   354,   356,
   358,   367,   373,   381,   389,   397,   405,   411,   416,   421,
   426,   429,   434,   439,   444,   449,   452,   455,   460,   465,
   470,   475,   478,   480,   482,   484,   486,   488,   490,   496,
   506,   516,   522,   528,   532,   538,   542,   548,   554,   560,
   566,   572,   578,   583,   589,   595,   602,   606,   612,   618,
   622,   628,   634,   638,   644,   650,   656,   660,   664,   668,
   672,   676,   681,   685,   689,   694,   699,   703,   707,   711,
   715,   719,   723,   727,   731,   733,   735,   737,   739,   741,
   743,   745,   747,   749,   753,   759,   763,   767,   771,   775,
   779,   783,   787,   791,   795,   799,   803,   807,   811,   815,
   819,   823,   826,   829,   832,   834,   836
};

static const short yyrhs[] = {    -1,
    77,    78,     0,    77,    80,    78,     0,    79,     0,    81,
    79,     0,    95,    79,     0,   106,    79,     0,     1,    79,
     0,    73,     0,    74,     0,    21,    52,     0,    22,    52,
     0,    27,   116,     0,    28,     0,    29,   116,     0,    30,
    86,     0,    34,    88,     0,    35,    90,     0,    36,    92,
     0,   116,    68,    30,   116,     0,   116,    68,    34,   116,
     0,   116,    68,    35,   116,     0,   116,    68,    36,    94,
     0,     0,    21,    82,    48,   116,     0,     0,    22,    83,
    48,   116,     0,     0,    21,    84,    32,   116,     0,     0,
    22,    85,    32,   116,     0,    31,     0,    31,   116,     0,
    31,   116,    75,   116,     0,    33,   116,     0,    87,     0,
    86,    75,    87,     0,   116,     0,    89,     0,    88,    75,
    89,     0,   116,     0,    91,     0,    90,    75,    91,     0,
   116,     0,    93,     0,    92,    75,    93,     0,    94,     0,
    24,     0,    67,    24,     0,    66,    24,     0,    96,     0,
    96,    48,   104,   101,   105,    10,    68,    97,     0,    96,
    48,   104,   101,   105,    97,     0,    96,    48,   104,    98,
     0,    96,    48,   104,    10,   105,    49,   100,    48,    98,
    50,    68,    97,     0,    96,    48,   104,    49,   100,    48,
    98,    50,    68,    97,     0,    96,    48,   104,    10,   105,
    98,    68,    97,     0,    96,    48,   104,    10,   105,    97,
     0,    96,    48,   104,   101,    68,    97,     0,    96,    48,
   104,    49,   100,    48,    98,    50,   105,    97,     0,    96,
    48,    37,    49,    99,    50,     0,    96,    48,    34,    49,
    99,    50,     0,    96,    48,    35,    49,    99,    50,     0,
    96,    48,    36,    49,    99,    50,     0,   101,    48,    10,
     0,   103,    48,    10,     0,   115,    48,    10,     0,    10,
     0,   101,     0,    10,     0,    17,     0,   101,     0,    10,
     0,    17,     0,    98,     0,    19,     0,   101,     0,   103,
     0,   115,     0,    68,   102,     0,    68,   102,     3,     0,
    68,   102,     4,     0,    68,   102,     3,   102,     0,     5,
     0,     7,     0,    68,   102,     3,     6,     0,    66,     0,
    67,     0,     0,    66,     0,    67,     0,   107,     0,   111,
     0,   114,     0,    38,    49,    45,    50,   108,     0,    38,
    49,    46,    50,   108,     0,    38,    49,    47,    50,   108,
     0,   109,     0,    42,     0,    44,     0,    38,    49,     5,
     4,    61,   117,    50,   108,     0,    40,   110,    49,   110,
    50,     0,    40,   110,    66,   116,    49,   110,    50,     0,
    40,   110,    67,   116,    49,   110,    50,     0,    40,    11,
    66,   116,    49,   110,    50,     0,    40,    11,    67,   116,
    49,   110,    50,     0,    40,   116,    49,   110,    50,     0,
    43,   116,    75,   116,     0,    43,   116,    75,     5,     0,
    41,    49,   110,    50,     0,    39,   110,     0,    39,   110,
    66,   116,     0,    39,   110,    67,   116,     0,    39,    11,
    66,   116,     0,    39,    11,    67,   116,     0,    39,   116,
     0,    39,   110,     0,    39,   110,    66,   116,     0,    39,
   110,    67,   116,     0,    39,    11,    66,   116,     0,    39,
    11,    67,   116,     0,    39,   116,     0,     5,     0,     7,
     0,     8,     0,     9,     0,   112,     0,   113,     0,    38,
    49,    45,    50,   112,     0,    38,    49,    45,    50,   110,
    48,   110,    66,    25,     0,    38,    49,    45,    50,   110,
    48,   110,    67,    25,     0,   110,    48,   110,    66,   110,
     0,   110,    48,   110,    67,   110,     0,   110,    67,   110,
     0,   110,    48,   110,    55,   110,     0,   110,    55,   110,
     0,   110,    48,   110,    53,   110,     0,   110,    48,   110,
    54,   110,     0,   110,    48,   110,    69,    26,     0,   110,
    48,   110,    63,    25,     0,   110,    48,   110,    64,    25,
     0,   110,    48,   110,    65,    25,     0,   110,    48,    67,
   110,     0,   110,    48,   110,    68,    26,     0,   110,    48,
   110,    76,   110,     0,   110,    48,   110,    55,    72,   110,
     0,   110,    48,   110,     0,   110,    48,   110,    66,   116,
     0,   110,    48,   110,    67,   116,     0,   110,    67,   116,
     0,   110,    48,   116,    67,   110,     0,   110,    48,   110,
    55,   116,     0,   110,    55,   116,     0,   110,    48,   110,
    53,   116,     0,   110,    48,   110,    54,   116,     0,   110,
    48,   110,    76,   116,     0,   110,    48,   116,     0,   110,
    48,   101,     0,   110,    48,   103,     0,   110,    48,   115,
     0,   115,    48,   110,     0,   110,    48,    68,   116,     0,
    16,    48,   116,     0,    15,    48,   116,     0,    68,   116,
    48,   110,     0,    68,   116,    48,    14,     0,   101,    48,
   110,     0,   103,    48,   110,     0,   101,    48,    14,     0,
   103,    48,    14,     0,   101,    48,   115,     0,   103,    48,
   115,     0,   115,    48,   101,     0,   115,    48,   103,     0,
    17,     0,    18,     0,    12,     0,    19,     0,    13,     0,
    20,     0,    21,     0,    22,     0,   117,     0,    49,   116,
    50,     0,   116,    51,   116,    52,   116,     0,   116,    53,
   116,     0,   116,    54,   116,     0,   116,    55,   116,     0,
   116,    56,   116,     0,   116,    57,   116,     0,   116,    58,
   116,     0,   116,    59,   116,     0,   116,    60,   116,     0,
   116,    61,   116,     0,   116,    62,   116,     0,   116,    63,
   116,     0,   116,    66,   116,     0,   116,    67,   116,     0,
   116,    68,   116,     0,   116,    69,   116,     0,   116,    70,
   116,     0,    71,   116,     0,    72,   116,     0,    67,   116,
     0,    23,     0,    25,     0,    26,     0
};

#endif

#if YYDEBUG != 0
static const short yyrline[] = { 0,
   232,   233,   234,   237,   238,   239,   240,   241,   244,   245,
   248,   249,   252,   258,   261,   267,   268,   269,   270,   271,
   272,   273,   274,   275,   275,   277,   277,   280,   280,   282,
   282,   284,   285,   286,   287,   290,   291,   293,   296,   297,
   299,   302,   303,   305,   308,   309,   311,   313,   314,   315,
   318,   320,   322,   324,   326,   328,   330,   332,   334,   336,
   338,   340,   342,   344,   348,   349,   350,   351,   354,   355,
   356,   359,   360,   361,   364,   365,   368,   369,   370,   373,
   374,   375,   376,   379,   380,   383,   386,   387,   388,   391,
   392,   395,   396,   397,   400,   401,   402,   403,   404,   405,
   406,   407,   408,   409,   410,   411,   412,   413,   414,   415,
   418,   419,   420,   421,   422,   423,   426,   427,   428,   429,
   430,   431,   434,   435,   436,   437,   440,   441,   442,   443,
   446,   451,   453,   455,   457,   459,   461,   463,   465,   467,
   469,   471,   473,   475,   477,   479,   481,   485,   486,   487,
   488,   489,   490,   491,   492,   493,   496,   498,   499,   500,
   501,   502,   503,   504,   505,   506,   507,   508,   509,   510,
   511,   512,   513,   514,   517,   518,   519,   520,   521,   522,
   525,   526,   527,   528,   529,   530,   531,   532,   533,   534,
   535,   536,   537,   538,   539,   540,   541,   542,   543,   544,
   547,   550,   551,   552,   555,   556,   557
};

static const char * const yytname[] = {   "$","error","$illegal.","PLSPLS","MINUSMINUS",
"REG","REGR","REGE","REGHL","REGIO","ACCUM","PC","PIOP","PIR","PCSH","DAUC",
"IOC","IBUF","OBUF","PDR","PCW","SYMBOL","LABEL","CONST","FCONST","CONST1","CONST2",
"ORG","END","ALIGN","BYTE","PAGE","EQU","LIST","INT","INT24","FLOAT","DA_FUN",
"IF","GOTO","CALL","RETURN","IRETURN","DO","NOP","CA_COND","DA_COND","IO_COND",
"'='","'('","')'","'?'","':'","'|'","'^'","'&'","EQUEQU","NOTEQU","'<'","'>'",
"LE","GE","LSHIFT","RSHIFT","RROTATE","LROTATE","'+'","'-'","'*'","'/'","'%'",
"'!'","'~'","';'","'\\n'","','","'#'","program","stmt","end_stmt","label","psuedo_op",
"@1","@2","@3","@4","byte_list","byte","word_list","word","quad_list","quad",
"float_list","float","fconst","da_instr","da_dest","x","y","y_spec","z","mem",
"reg_e","mem_r","f","s","ca_instr","control","goto16","goto24","any_reg","arith_logic",
"a_l_reg","a_l_immed","data_move","io_port","expr","const",""
};
#endif

static const short yyr1[] = {     0,
    77,    77,    77,    78,    78,    78,    78,    78,    79,    79,
    80,    80,    81,    81,    81,    81,    81,    81,    81,    81,
    81,    81,    81,    82,    81,    83,    81,    84,    81,    85,
    81,    81,    81,    81,    81,    86,    86,    87,    88,    88,
    89,    90,    90,    91,    92,    92,    93,    94,    94,    94,
    95,    95,    95,    95,    95,    95,    95,    95,    95,    95,
    95,    95,    95,    95,    96,    96,    96,    96,    97,    97,
    97,    98,    98,    98,    99,    99,   100,   100,   100,   101,
   101,   101,   101,   102,   102,   103,   104,   104,   104,   105,
   105,   106,   106,   106,   107,   107,   107,   107,   107,   107,
   107,   107,   107,   107,   107,   107,   107,   107,   107,   107,
   108,   108,   108,   108,   108,   108,   109,   109,   109,   109,
   109,   109,   110,   110,   110,   110,   111,   111,   111,   111,
   111,   112,   112,   112,   112,   112,   112,   112,   112,   112,
   112,   112,   112,   112,   112,   112,   112,   113,   113,   113,
   113,   113,   113,   113,   113,   113,   114,   114,   114,   114,
   114,   114,   114,   114,   114,   114,   114,   114,   114,   114,
   114,   114,   114,   114,   115,   115,   115,   115,   115,   115,
   116,   116,   116,   116,   116,   116,   116,   116,   116,   116,
   116,   116,   116,   116,   116,   116,   116,   116,   116,   116,
   116,   116,   116,   116,   117,   117,   117
};

static const short yyr2[] = {     0,
     0,     2,     3,     1,     2,     2,     2,     2,     1,     1,
     2,     2,     2,     1,     2,     2,     2,     2,     2,     4,
     4,     4,     4,     0,     4,     0,     4,     0,     4,     0,
     4,     1,     2,     4,     2,     1,     3,     1,     1,     3,
     1,     1,     3,     1,     1,     3,     1,     1,     2,     2,
     1,     8,     6,     4,    12,    10,     8,     6,     6,    10,
     6,     6,     6,     6,     3,     3,     3,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,
     3,     3,     4,     1,     1,     4,     1,     1,     0,     1,
     1,     1,     1,     1,     5,     5,     5,     1,     1,     1,
     8,     5,     7,     7,     7,     7,     5,     4,     4,     4,
     2,     4,     4,     4,     4,     2,     2,     4,     4,     4,
     4,     2,     1,     1,     1,     1,     1,     1,     5,     9,
     9,     5,     5,     3,     5,     3,     5,     5,     5,     5,
     5,     5,     4,     5,     5,     6,     3,     5,     5,     3,
     5,     5,     3,     5,     5,     5,     3,     3,     3,     3,
     3,     4,     3,     3,     4,     4,     3,     3,     3,     3,
     3,     3,     3,     3,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     3,     5,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     2,     2,     2,     1,     1,     1
};

static const short yydefact[] = {     1,
     0,     0,   123,   124,   125,   126,    68,   177,   179,     0,
     0,   175,   176,   178,   180,   181,   182,   205,   206,   207,
     0,    14,     0,     0,    32,     0,     0,     0,     0,     0,
     0,     0,     0,    99,     0,   100,     0,     0,     0,     0,
     0,     9,    10,     2,     4,     0,     0,     0,    51,     0,
     0,     0,    92,    98,     0,    93,   127,   128,    94,     0,
     0,   183,     8,     0,     0,    11,     0,     0,    12,     0,
     0,   181,   182,    13,    15,    16,    36,    38,    33,    35,
    17,    39,    41,    18,    42,    44,    48,     0,     0,    19,
    45,    47,     0,     0,   117,   122,     0,     0,     0,     0,
     0,     0,   204,    84,    85,    80,     0,   202,   203,   181,
   182,     3,     5,     6,    89,     0,     0,     7,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   164,
   163,     0,     0,     0,     0,     0,     0,     0,     0,     0,
    50,    49,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   184,
    81,    82,     0,     0,     0,     0,     0,    87,    88,     0,
    65,   169,   167,   171,    66,   170,   168,   172,     0,     0,
   158,   159,   147,   160,   157,   136,   153,   134,   150,    67,
     0,   173,   174,   161,     0,   186,   187,   188,   189,   190,
   191,   192,   193,   194,   195,   196,   197,   198,     0,     0,
     0,     0,   199,   200,   201,    25,    29,    27,    31,    37,
    34,    40,    43,    46,     0,     0,     0,     0,   120,   121,
   118,   119,     0,     0,     0,     0,     0,     0,   110,   109,
   108,    86,    83,   166,   165,     0,     0,     0,     0,    73,
    74,     0,     0,    54,    72,   143,   162,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
    20,    21,    22,    23,     0,     0,    95,     0,   129,    96,
    97,     0,     0,   102,     0,     0,   107,    73,    76,    75,
     0,    72,     0,     0,     0,    90,    91,     0,     0,    77,
    78,    79,    80,     0,     0,   137,   154,   138,   155,     0,
   135,   152,   140,   141,   142,   132,   148,   133,   149,   144,
   139,   145,   156,   151,   185,     0,     0,   111,   116,     0,
     0,     0,     0,     0,     0,     0,    62,    63,    64,    61,
    70,    71,     0,    58,     0,    69,     0,    81,    70,    71,
    59,    69,    70,    53,   146,     0,     0,     0,     0,     0,
     0,   147,   105,   106,   103,   104,     0,     0,     0,     0,
   101,   114,   115,   112,   113,     0,     0,     0,     0,     0,
     0,     0,    57,     0,    52,     0,   130,   131,     0,     0,
     0,     0,    56,    60,     0,    55,     0,     0
};

static const short yydefgoto[] = {     1,
    44,    45,    46,    47,    67,    70,    68,    71,    76,    77,
    81,    82,    84,    85,    90,    91,    92,    48,    49,   354,
   300,   301,   309,   362,   106,    51,   180,   308,    52,    53,
   287,    54,    55,    56,    57,    58,    59,    60,    61,    62
};

static const short yypact[] = {-32768,
   518,   -50,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   -29,
   -11,-32768,-32768,-32768,-32768,   244,   305,-32768,-32768,-32768,
   249,-32768,   249,   249,   249,   249,   249,   249,     3,     9,
    42,   143,    12,-32768,   249,-32768,   249,   249,   677,   249,
   249,-32768,-32768,-32768,-32768,   607,   -50,   -50,    23,    54,
    62,   -50,-32768,-32768,    -7,-32768,-32768,-32768,-32768,    76,
   870,-32768,-32768,   249,   249,-32768,    91,    46,-32768,    94,
   124,-32768,-32768,   890,   890,    85,-32768,   890,   418,   890,
    92,-32768,   890,   110,-32768,   890,-32768,   146,   201,   160,
-32768,-32768,    41,   -38,    16,   890,    30,   157,   721,   657,
   441,   830,-32768,-32768,-32768,   208,   699,-32768,-32768,    74,
    79,-32768,-32768,-32768,   336,   993,  1009,-32768,    13,   182,
   182,    47,   249,   249,   249,   249,   249,   249,   249,   249,
   249,   249,   249,   249,   249,   249,   671,   249,   249,   890,
   890,   249,   249,   249,   249,   249,   249,   249,   249,   249,
-32768,-32768,     3,   241,   200,   217,   223,   249,   249,   249,
   249,   249,   249,   657,   249,   249,   657,   227,   325,-32768,
    10,-32768,   375,   232,   239,   248,   257,-32768,-32768,    49,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   182,   677,
-32768,-32768,   236,-32768,   910,-32768,   890,-32768,   890,-32768,
   140,-32768,-32768,-32768,   850,   927,   349,   537,   973,   986,
   591,   591,   591,   591,   386,   386,   112,   112,   249,   249,
   249,     3,-32768,-32768,-32768,   890,   890,   890,   890,-32768,
   890,-32768,-32768,-32768,   250,   188,   280,   280,   890,   890,
   890,   890,   743,   765,   273,   787,   809,   281,-32768,-32768,
   890,-32768,-32768,-32768,-32768,   106,   106,   106,   106,   172,
-32768,   267,   140,-32768,   134,-32768,   890,   182,   182,   211,
   309,   318,   320,   182,   182,   323,   332,   182,   182,   249,
   890,   890,   890,-32768,   107,   150,-32768,    53,-32768,-32768,
-32768,   657,   657,-32768,   657,   657,-32768,-32768,-32768,-32768,
   317,-32768,   326,   331,   335,-32768,-32768,    95,   338,-32768,
-32768,-32768,   291,   109,   118,-32768,   890,-32768,   890,   182,
-32768,   890,-32768,-32768,-32768,-32768,   890,-32768,   890,-32768,
-32768,-32768,   890,-32768,   890,   337,   251,   288,   890,    67,
   657,   657,   340,   343,   344,   348,-32768,-32768,-32768,-32768,
   300,   333,   267,-32768,   345,   346,   126,   140,-32768,-32768,
-32768,-32768,   355,-32768,-32768,   280,   249,   249,   249,   249,
   657,   664,-32768,-32768,-32768,-32768,   351,   109,   350,   109,
-32768,   890,   890,   890,   890,   657,   657,    35,   221,   370,
   657,   126,-32768,   196,-32768,   657,-32768,-32768,   391,   109,
   109,   374,-32768,-32768,   109,-32768,   388,-32768
};

static const short yypgoto[] = {-32768,
   411,   136,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   311,
-32768,   316,-32768,   339,-32768,   315,   260,-32768,-32768,  -301,
  -179,    51,   130,    -1,  -160,  -113,-32768,  -253,-32768,-32768,
  -235,-32768,   -27,-32768,   269,-32768,-32768,  -109,   301,   228
};


#define	YYLAST		1056


static const short yytable[] = {    50,
   264,   290,   291,    95,    98,   192,   184,   188,   203,   194,
   253,   315,   361,   364,   104,   252,   105,     3,    64,     4,
     5,     6,    42,    43,     8,     9,    87,   158,   159,    12,
    13,    14,    15,    72,    73,    18,    65,    19,    20,     3,
   119,     4,     5,     6,    50,   154,     3,   120,     4,     5,
     6,     3,    94,     4,     5,     6,   200,    93,   260,   121,
   100,    37,    72,    73,    18,   261,    19,    20,    88,    89,
   115,     3,   168,     4,     5,     6,   393,   143,   395,   189,
   190,   160,   161,    40,    41,   155,   156,   157,   183,   187,
    37,   193,   196,   198,   204,   162,   163,   262,   403,   404,
   340,   116,   313,   406,   351,   -28,   396,   341,    38,   117,
   -30,   352,    40,    41,   201,   298,   263,   191,   359,   342,
   202,   -24,   261,   122,   299,   360,   -26,   363,   355,    18,
   381,    19,    20,   371,   360,   298,   245,    63,   142,   248,
   401,   144,   261,   353,   104,   255,   105,     3,   311,     4,
     5,     6,   312,    97,     3,   145,     4,     5,     6,   147,
   337,   266,   263,    72,    73,    18,   149,    19,    20,   151,
    72,    73,    18,   263,    19,    20,   263,   379,   265,   146,
   138,   139,   113,   114,   150,   263,     3,   118,     4,     5,
     6,    37,     3,   263,     4,     5,     6,   253,    37,   306,
   307,   314,    72,    73,    18,   164,    19,    20,   288,    38,
   171,   172,   399,    40,    41,     3,    38,     4,     5,     6,
    40,    41,   165,   166,   152,     3,   286,     4,     5,     6,
    37,    72,    73,    18,   153,    19,    20,   306,   307,   311,
   316,   318,   321,   312,   235,   397,   326,   328,    38,   236,
   332,   334,    40,    41,   302,   302,   302,   302,   338,    37,
   310,   306,   307,   400,   343,   344,   237,   345,   346,    72,
    73,    18,   238,    19,    20,   -28,   249,    38,     8,     9,
   256,    40,   320,    12,    13,    14,    15,   257,   268,   269,
   270,   -24,   365,   358,   172,    66,   258,    37,   271,   272,
   273,   274,   275,   276,   277,   259,   356,   303,   304,   305,
   285,   278,   372,   196,   198,    38,   367,   368,   286,    40,
    41,    74,   294,    75,    78,    79,    80,    83,    86,   250,
   297,    96,    99,   323,   201,   101,   -30,   102,   103,   107,
   108,   109,   324,   266,   325,    72,    73,    18,   330,    19,
    20,   310,   -26,   369,   370,   302,    69,   331,   316,   318,
   321,   326,   328,   332,   140,   141,   347,   -73,   365,   174,
   175,   176,   177,    37,     3,   348,     4,     5,     6,     3,
   349,     4,     5,     6,   350,   357,   366,   408,   254,   373,
   302,    38,   374,   375,   398,    40,    41,   376,   392,   394,
   -74,   178,   179,   126,   127,   128,   129,   130,   131,   132,
   133,   134,   378,   -72,   135,   136,   146,   138,   139,   195,
   197,   199,   380,   205,   206,   207,   208,   209,   210,   211,
   212,   213,   214,   215,   216,   217,   218,   223,   224,   225,
   402,   405,   226,   227,   228,   229,   223,    78,   231,    83,
    86,   135,   136,   146,   138,   139,   112,   230,   239,   240,
   241,   242,   243,   244,   232,   246,   247,   234,   123,   251,
   124,   125,   126,   127,   128,   129,   130,   131,   132,   133,
   134,   284,   377,   135,   136,   146,   138,   139,   233,   103,
   267,   123,   148,   124,   125,   126,   127,   128,   129,   130,
   131,   132,   133,   134,   289,     0,   135,   136,   146,   138,
   139,     0,   336,     0,     0,   169,     0,   407,     2,   281,
   282,   283,     3,     0,     4,     5,     6,     7,     0,     8,
     9,     0,    10,    11,    12,    13,    14,    15,    16,    17,
    18,     0,    19,    20,    21,    22,    23,    24,    25,     0,
    26,    27,    28,    29,     0,    30,    31,    32,    33,    34,
    35,    36,     0,     0,     0,     0,    37,     0,   317,   319,
   322,     0,     0,     0,   327,   329,     0,     0,   333,   218,
   335,     0,     0,     0,    38,    39,   339,     0,    40,    41,
    42,    43,   127,   128,   129,   130,   131,   132,   133,   134,
     0,     0,   135,   136,   146,   138,   139,     2,     0,     0,
     0,     3,     0,     4,     5,     6,     7,     0,     8,     9,
   109,    10,    11,    12,    13,    14,    15,   110,   111,    18,
     0,    19,    20,    21,    22,    23,    24,    25,     0,    26,
    27,    28,    29,     0,    30,    31,    32,    33,    34,    35,
    36,     0,   133,   134,     0,    37,   135,   136,   146,   138,
   139,     3,     0,     4,     5,     6,     0,   382,   383,   384,
   385,     0,     0,    38,    39,     0,     0,    40,    41,    42,
    43,   104,     0,   105,     0,     0,     0,     0,     0,     0,
     0,    72,    73,    18,     0,    19,    20,    72,    73,    18,
   219,    19,    20,     0,   220,   221,   222,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   386,   387,   388,    37,
     0,     0,     0,     0,     0,    37,   271,   272,   273,   389,
   390,   276,   277,     0,     0,     0,     0,    38,     0,   391,
     0,    40,    41,    38,     0,     0,   173,    40,    41,   123,
     0,   124,   125,   126,   127,   128,   129,   130,   131,   132,
   133,   134,     0,     0,   135,   136,   146,   138,   139,   167,
     0,   123,     0,   124,   125,   126,   127,   128,   129,   130,
   131,   132,   133,   134,     0,     0,   135,   136,   146,   138,
   139,   292,     0,   123,     0,   124,   125,   126,   127,   128,
   129,   130,   131,   132,   133,   134,     0,     0,   135,   136,
   146,   138,   139,   293,     0,   123,     0,   124,   125,   126,
   127,   128,   129,   130,   131,   132,   133,   134,     0,     0,
   135,   136,   146,   138,   139,   295,     0,   123,     0,   124,
   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,
     0,     0,   135,   136,   146,   138,   139,   296,     0,   123,
     0,   124,   125,   126,   127,   128,   129,   130,   131,   132,
   133,   134,     0,     0,   135,   136,   146,   138,   139,   170,
   123,     0,   124,   125,   126,   127,   128,   129,   130,   131,
   132,   133,   134,     0,     0,   135,   136,   146,   138,   139,
   123,   280,   124,   125,   126,   127,   128,   129,   130,   131,
   132,   133,   134,     0,     0,   135,   136,   146,   138,   139,
   123,     0,   124,   125,   126,   127,   128,   129,   130,   131,
   132,   133,   134,     0,     0,   135,   136,   137,   138,   139,
   123,     0,   124,   125,   126,   127,   128,   129,   130,   131,
   132,   133,   134,     0,     0,   135,   136,   146,   138,   139,
   123,     0,   124,   125,   126,   127,   128,   129,   130,   131,
   132,   133,   134,     0,     0,   135,   279,   146,   138,   139,
   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,
     0,     0,   135,   136,   146,   138,   139,     3,     0,     4,
     5,     6,   181,     0,     8,     9,   182,     0,     0,    12,
    13,    14,    15,     3,     0,     4,     5,     6,   185,     0,
     8,     9,   186,     0,     0,    12,    13,    14,    15,   128,
   129,   130,   131,   132,   133,   134,     0,     0,   135,   136,
   146,   138,   139,   129,   130,   131,   132,   133,   134,     0,
     0,   135,   136,   146,   138,   139
};

static const short yycheck[] = {     1,
   180,   237,   238,    31,    32,   119,   116,   117,   122,   119,
   171,   265,   314,   315,     5,     6,     7,     5,    48,     7,
     8,     9,    73,    74,    12,    13,    24,    66,    67,    17,
    18,    19,    20,    21,    22,    23,    48,    25,    26,     5,
    48,     7,     8,     9,    46,     5,     5,    55,     7,     8,
     9,     5,    11,     7,     8,     9,    10,    49,    10,    67,
    49,    49,    21,    22,    23,    17,    25,    26,    66,    67,
    48,     5,   100,     7,     8,     9,   378,    32,   380,    67,
    68,    66,    67,    71,    72,    45,    46,    47,   116,   117,
    49,   119,   120,   121,   122,    66,    67,    49,   400,   401,
    48,    48,   263,   405,    10,    32,    72,    55,    67,    48,
    32,    17,    71,    72,    68,    10,    68,   119,    10,    67,
   122,    48,    17,    48,    19,    17,    48,    10,   308,    23,
   366,    25,    26,    67,    17,    10,   164,     2,    48,   167,
   394,    48,    17,    49,     5,   173,     7,     5,   262,     7,
     8,     9,   262,    11,     5,    32,     7,     8,     9,    75,
    11,   189,    68,    21,    22,    23,    75,    25,    26,    24,
    21,    22,    23,    68,    25,    26,    68,   357,   180,    68,
    69,    70,    47,    48,    75,    68,     5,    52,     7,     8,
     9,    49,     5,    68,     7,     8,     9,   358,    49,    66,
    67,    68,    21,    22,    23,    49,    25,    26,   236,    67,
     3,     4,   392,    71,    72,     5,    67,     7,     8,     9,
    71,    72,    66,    67,    24,     5,    39,     7,     8,     9,
    49,    21,    22,    23,    75,    25,    26,    66,    67,   353,
   268,   269,   270,   353,     4,    25,   274,   275,    67,    50,
   278,   279,    71,    72,   256,   257,   258,   259,   286,    49,
   262,    66,    67,    68,   292,   293,    50,   295,   296,    21,
    22,    23,    50,    25,    26,    32,    50,    67,    12,    13,
    49,    71,    72,    17,    18,    19,    20,    49,    53,    54,
    55,    48,   320,     3,     4,    52,    49,    49,    63,    64,
    65,    66,    67,    68,    69,    49,   308,   257,   258,   259,
    61,    76,   340,   341,   342,    67,    66,    67,    39,    71,
    72,    21,    50,    23,    24,    25,    26,    27,    28,     5,
    50,    31,    32,    25,    68,    35,    32,    37,    38,    39,
    40,    41,    25,   371,    25,    21,    22,    23,    26,    25,
    26,   353,    48,    66,    67,   357,    52,    26,   386,   387,
   388,   389,   390,   391,    64,    65,    50,    68,   396,    34,
    35,    36,    37,    49,     5,    50,     7,     8,     9,     5,
    50,     7,     8,     9,    50,    48,    50,     0,    14,    50,
   392,    67,    50,    50,    25,    71,    72,    50,    48,    50,
    68,    66,    67,    55,    56,    57,    58,    59,    60,    61,
    62,    63,    68,    68,    66,    67,    68,    69,    70,   119,
   120,   121,    68,   123,   124,   125,   126,   127,   128,   129,
   130,   131,   132,   133,   134,   135,   136,   137,   138,   139,
    50,    68,   142,   143,   144,   145,   146,   147,   148,   149,
   150,    66,    67,    68,    69,    70,    46,   147,   158,   159,
   160,   161,   162,   163,   149,   165,   166,   153,    51,   169,
    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
    63,   222,   353,    66,    67,    68,    69,    70,   150,   189,
   190,    51,    75,    53,    54,    55,    56,    57,    58,    59,
    60,    61,    62,    63,   236,    -1,    66,    67,    68,    69,
    70,    -1,   285,    -1,    -1,    75,    -1,     0,     1,   219,
   220,   221,     5,    -1,     7,     8,     9,    10,    -1,    12,
    13,    -1,    15,    16,    17,    18,    19,    20,    21,    22,
    23,    -1,    25,    26,    27,    28,    29,    30,    31,    -1,
    33,    34,    35,    36,    -1,    38,    39,    40,    41,    42,
    43,    44,    -1,    -1,    -1,    -1,    49,    -1,   268,   269,
   270,    -1,    -1,    -1,   274,   275,    -1,    -1,   278,   279,
   280,    -1,    -1,    -1,    67,    68,   286,    -1,    71,    72,
    73,    74,    56,    57,    58,    59,    60,    61,    62,    63,
    -1,    -1,    66,    67,    68,    69,    70,     1,    -1,    -1,
    -1,     5,    -1,     7,     8,     9,    10,    -1,    12,    13,
   320,    15,    16,    17,    18,    19,    20,    21,    22,    23,
    -1,    25,    26,    27,    28,    29,    30,    31,    -1,    33,
    34,    35,    36,    -1,    38,    39,    40,    41,    42,    43,
    44,    -1,    62,    63,    -1,    49,    66,    67,    68,    69,
    70,     5,    -1,     7,     8,     9,    -1,   367,   368,   369,
   370,    -1,    -1,    67,    68,    -1,    -1,    71,    72,    73,
    74,     5,    -1,     7,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,    21,    22,    23,    -1,    25,    26,    21,    22,    23,
    30,    25,    26,    -1,    34,    35,    36,    -1,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    -1,    53,    54,    55,    49,
    -1,    -1,    -1,    -1,    -1,    49,    63,    64,    65,    66,
    67,    68,    69,    -1,    -1,    -1,    -1,    67,    -1,    76,
    -1,    71,    72,    67,    -1,    -1,    48,    71,    72,    51,
    -1,    53,    54,    55,    56,    57,    58,    59,    60,    61,
    62,    63,    -1,    -1,    66,    67,    68,    69,    70,    49,
    -1,    51,    -1,    53,    54,    55,    56,    57,    58,    59,
    60,    61,    62,    63,    -1,    -1,    66,    67,    68,    69,
    70,    49,    -1,    51,    -1,    53,    54,    55,    56,    57,
    58,    59,    60,    61,    62,    63,    -1,    -1,    66,    67,
    68,    69,    70,    49,    -1,    51,    -1,    53,    54,    55,
    56,    57,    58,    59,    60,    61,    62,    63,    -1,    -1,
    66,    67,    68,    69,    70,    49,    -1,    51,    -1,    53,
    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,
    -1,    -1,    66,    67,    68,    69,    70,    49,    -1,    51,
    -1,    53,    54,    55,    56,    57,    58,    59,    60,    61,
    62,    63,    -1,    -1,    66,    67,    68,    69,    70,    50,
    51,    -1,    53,    54,    55,    56,    57,    58,    59,    60,
    61,    62,    63,    -1,    -1,    66,    67,    68,    69,    70,
    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,
    61,    62,    63,    -1,    -1,    66,    67,    68,    69,    70,
    51,    -1,    53,    54,    55,    56,    57,    58,    59,    60,
    61,    62,    63,    -1,    -1,    66,    67,    68,    69,    70,
    51,    -1,    53,    54,    55,    56,    57,    58,    59,    60,
    61,    62,    63,    -1,    -1,    66,    67,    68,    69,    70,
    51,    -1,    53,    54,    55,    56,    57,    58,    59,    60,
    61,    62,    63,    -1,    -1,    66,    67,    68,    69,    70,
    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,
    -1,    -1,    66,    67,    68,    69,    70,     5,    -1,     7,
     8,     9,    10,    -1,    12,    13,    14,    -1,    -1,    17,
    18,    19,    20,     5,    -1,     7,     8,     9,    10,    -1,
    12,    13,    14,    -1,    -1,    17,    18,    19,    20,    57,
    58,    59,    60,    61,    62,    63,    -1,    -1,    66,    67,
    68,    69,    70,    58,    59,    60,    61,    62,    63,    -1,
    -1,    66,    67,    68,    69,    70
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/usr/local/lib/bison.simple"

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */


#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		-2
#define YYEOF		0
#define YYACCEPT	return(0)
#define YYABORT 	return(1)
#define YYERROR		goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL		goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    { yychar = (token), yylval = (value);			\
      yychar1 = YYTRANSLATE (yychar);				\
      YYPOPSTACK;						\
      goto yybackup;						\
    }								\
  else								\
    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
while (0)

#define YYTERROR	1
#define YYERRCODE	256

#ifndef YYPURE
#define YYLEX		yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#define YYLEX		yylex(&yylval, &yylloc)
#else
#define YYLEX		yylex(&yylval)
#endif
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int	yychar;			/*  the lookahead symbol		*/
YYSTYPE	yylval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int yynerrs;			/*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int yyparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __yy_bcopy(FROM,TO,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_bcopy (from, to, count)
     char *from;
     char *to;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__yy_bcopy (char *from, char *to, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif

#line 184 "/usr/local/lib/bison.simple"
int
yyparse()
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YYSTYPE *yyvsp;
  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/

  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
  YYLTYPE *yyls = yylsa;
  YYLTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YYPURE
  int yychar;
  YYSTYPE yylval;
  int yynerrs;
#ifdef YYLSP_NEEDED
  YYLTYPE yylloc;
#endif
#endif

  YYSTYPE yyval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int yylen;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Starting parse\n");
#endif

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YYLSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
yynewstate:

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YYSTYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YYLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YYLSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  yyerror("parser stack overflow");
	  return 2;
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
      __yy_bcopy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
      __yy_bcopy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
#ifdef YYLSP_NEEDED
      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
      __yy_bcopy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  goto yybackup;
 yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yydefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (yychar == YYEMPTY)
    {
#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Reading a token: ");
#endif
      yychar = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

#if YYDEBUG != 0
      if (yydebug)
	{
	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, yychar, yylval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    goto yydefault;

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  goto yynewstate;

/* Do the default action for the current state.  */
yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
  if (yydebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


  switch (yyn) {

case 2:
#line 233 "asm32.y"
{ end_stmt(); ;
    break;}
case 3:
#line 234 "asm32.y"
{ end_stmt(); ;
    break;}
case 8:
#line 241 "asm32.y"
{ yyerrok; errormsg("Syntax Error"); ;
    break;}
case 11:
#line 248 "asm32.y"
{ Symbol_def = Last_symbol; define_label(Org); ;
    break;}
case 12:
#line 249 "asm32.y"
{ Symbol_def = Last_symbol; define_label(Org); ;
    break;}
case 13:
#line 252 "asm32.y"
{ if(yyvsp[0].value >= 0L && yyvsp[0].value < MAX_DATA)
						Org = yyvsp[0].value;
					  else
						errormsg("Illegal Origin");
					  list_address(Org);
					;
    break;}
case 14:
#line 258 "asm32.y"
{ list_address(Org); list_print();
					  if(Org != UNDEFINED) YYACCEPT;
					;
    break;}
case 15:
#line 261 "asm32.y"
{ if(yyvsp[0].value > 1024L || yyvsp[0].value < 1L)
						errormsg("Illegal Alignment");
					  else
						while(Org % yyvsp[0].value)
							define_data(0L,1);
					;
    break;}
case 20:
#line 271 "asm32.y"
{ define_array(yyvsp[-3].value,yyvsp[0].value,1); ;
    break;}
case 21:
#line 272 "asm32.y"
{ define_array(yyvsp[-3].value,yyvsp[0].value,2); ;
    break;}
case 22:
#line 273 "asm32.y"
{ define_array(yyvsp[-3].value,yyvsp[0].value,4); ;
    break;}
case 23:
#line 274 "asm32.y"
{ define_array(yyvsp[-3].value,yyvsp[0].value,4); ;
    break;}
case 24:
#line 275 "asm32.y"
{ Symbol_def = Last_symbol; ;
    break;}
case 25:
#line 276 "asm32.y"
{ define_symbol(yyvsp[0].value); ;
    break;}
case 26:
#line 277 "asm32.y"
{ Symbol_def = Last_symbol; ;
    break;}
case 27:
#line 278 "asm32.y"
{ error_symbol("Attempt to Re-Define Label",
								Symbol_def); ;
    break;}
case 28:
#line 280 "asm32.y"
{ Symbol_def = Last_symbol; ;
    break;}
case 29:
#line 281 "asm32.y"
{ define_label(yyvsp[0].value); ;
    break;}
case 30:
#line 282 "asm32.y"
{ Symbol_def = Last_symbol; ;
    break;}
case 31:
#line 283 "asm32.y"
{ define_label(yyvsp[0].value); ;
    break;}
case 32:
#line 284 "asm32.y"
{ list_page(1); ;
    break;}
case 33:
#line 285 "asm32.y"
{ Page_length = yyvsp[0].value; ;
    break;}
case 34:
#line 286 "asm32.y"
{ Page_length = yyvsp[-2].value; Page_width = yyvsp[0].value; ;
    break;}
case 35:
#line 287 "asm32.y"
{ List_type = yyvsp[0].value; ;
    break;}
case 38:
#line 293 "asm32.y"
{ define_data(yyvsp[0].value,1); ;
    break;}
case 41:
#line 299 "asm32.y"
{ define_data(yyvsp[0].value,2); ;
    break;}
case 44:
#line 305 "asm32.y"
{ define_data(yyvsp[0].value,4); ;
    break;}
case 47:
#line 311 "asm32.y"
{ define_data(yyvsp[0].value,4); ;
    break;}
case 49:
#line 314 "asm32.y"
{ yyval.value = dspnegfloat(yyvsp[0].value); ;
    break;}
case 50:
#line 315 "asm32.y"
{ yyval.value = yyvsp[0].value; ;
    break;}
case 51:
#line 319 "asm32.y"
{ da_1(1,4,0,0,yyvsp[0].value,0,yyvsp[0].value&0x3L,7); ;
    break;}
case 52:
#line 321 "asm32.y"
{ da_1(1,yyvsp[-2].value,yyvsp[-5].value,yyvsp[-3].value,yyvsp[-7].value,yyvsp[0].value,yyvsp[-4].value,7); ;
    break;}
case 53:
#line 323 "asm32.y"
{ da_1(1,5,yyvsp[-3].value,yyvsp[-1].value,yyvsp[-5].value,yyvsp[0].value,yyvsp[-2].value,7); ;
    break;}
case 54:
#line 325 "asm32.y"
{ da_1(1,4,yyvsp[-1].value,0,yyvsp[-3].value,0,yyvsp[0].value,7); ;
    break;}
case 55:
#line 327 "asm32.y"
{ da_1(2,yyvsp[-8].value,yyvsp[-9].value,yyvsp[-7].value,yyvsp[-11].value,yyvsp[0].value,yyvsp[-3].value,yyvsp[-5].value); ;
    break;}
case 56:
#line 329 "asm32.y"
{ da_1(2,4,0,yyvsp[-7].value,yyvsp[-9].value,yyvsp[0].value,yyvsp[-3].value,yyvsp[-5].value); ;
    break;}
case 57:
#line 331 "asm32.y"
{ da_1(3,yyvsp[-4].value,yyvsp[-5].value,yyvsp[-3].value,yyvsp[-7].value,yyvsp[0].value,yyvsp[-2].value,7); ;
    break;}
case 58:
#line 333 "asm32.y"
{ da_1(1,5,yyvsp[-3].value,yyvsp[-1].value,yyvsp[-5].value,yyvsp[0].value,yyvsp[-2].value,7); ;
    break;}
case 59:
#line 335 "asm32.y"
{ da_1(3,4,0,yyvsp[-3].value,yyvsp[-5].value,yyvsp[0].value,yyvsp[-2].value,7); ;
    break;}
case 60:
#line 337 "asm32.y"
{ da_1(1,6,yyvsp[-7].value,yyvsp[-1].value,yyvsp[-9].value,yyvsp[0].value,yyvsp[-3].value,yyvsp[-5].value); ;
    break;}
case 61:
#line 339 "asm32.y"
{ da_5(yyvsp[-3].value,yyvsp[-5].value,yyvsp[-1].value); ;
    break;}
case 62:
#line 341 "asm32.y"
{ da_5(yyvsp[-3].value,yyvsp[-5].value,yyvsp[-1].value); ;
    break;}
case 63:
#line 343 "asm32.y"
{ da_5(yyvsp[-3].value,yyvsp[-5].value,yyvsp[-1].value); ;
    break;}
case 64:
#line 345 "asm32.y"
{ da_5(yyvsp[-3].value,yyvsp[-5].value,yyvsp[-1].value); ;
    break;}
case 65:
#line 348 "asm32.y"
{ yyval.value = (yyvsp[0].value<<21) | yyvsp[-2].value; ;
    break;}
case 66:
#line 349 "asm32.y"
{ yyval.value = (yyvsp[0].value<<21) | yyvsp[-2].value; ;
    break;}
case 67:
#line 350 "asm32.y"
{ yyval.value = (yyvsp[0].value<<21) | yyvsp[-2].value; ;
    break;}
case 68:
#line 351 "asm32.y"
{ yyval.value = (yyvsp[0].value<<21) | 7; ;
    break;}
case 70:
#line 355 "asm32.y"
{yyval.value = mem_ref(0,yyvsp[0].value); ;
    break;}
case 71:
#line 356 "asm32.y"
{yyval.value = mem_ref(0,yyvsp[0].value); ;
    break;}
case 73:
#line 360 "asm32.y"
{yyval.value = mem_ref(0,yyvsp[0].value); ;
    break;}
case 74:
#line 361 "asm32.y"
{yyval.value = mem_ref(0,yyvsp[0].value); ;
    break;}
case 76:
#line 365 "asm32.y"
{yyval.value = mem_ref(0,yyvsp[0].value); ;
    break;}
case 80:
#line 373 "asm32.y"
{yyval.value = mem_ref(yyvsp[0].value,16); ;
    break;}
case 81:
#line 374 "asm32.y"
{yyval.value = mem_ref(yyvsp[-1].value,23); ;
    break;}
case 82:
#line 375 "asm32.y"
{yyval.value = mem_ref(yyvsp[-1].value,22); ;
    break;}
case 83:
#line 376 "asm32.y"
{yyval.value = mem_ref(yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 86:
#line 383 "asm32.y"
{yyval.value = mem_ref(yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 87:
#line 386 "asm32.y"
{yyval.value = 0L;;
    break;}
case 88:
#line 387 "asm32.y"
{yyval.value = 1L;;
    break;}
case 89:
#line 388 "asm32.y"
{yyval.value = 0L;;
    break;}
case 90:
#line 391 "asm32.y"
{yyval.value = 0;;
    break;}
case 91:
#line 392 "asm32.y"
{yyval.value = 1;;
    break;}
case 95:
#line 400 "asm32.y"
{ ca_0(yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 96:
#line 401 "asm32.y"
{ ca_0(yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 97:
#line 402 "asm32.y"
{ ca_0(yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 98:
#line 403 "asm32.y"
{ ; ;
    break;}
case 99:
#line 404 "asm32.y"
{ define_data(0x003E0000L,4); ;
    break;}
case 100:
#line 405 "asm32.y"
{ define_data(0L,4); ;
    break;}
case 101:
#line 406 "asm32.y"
{ ca_3a(yyvsp[-5].value,yyvsp[0].value); ;
    break;}
case 102:
#line 407 "asm32.y"
{ ca_4(yyvsp[-1].value,yyvsp[-3].value,0L); ;
    break;}
case 103:
#line 408 "asm32.y"
{ ca_4(yyvsp[-1].value,yyvsp[-5].value,yyvsp[-3].value); ;
    break;}
case 104:
#line 409 "asm32.y"
{ ca_4(yyvsp[-1].value,yyvsp[-5].value,-yyvsp[-3].value); ;
    break;}
case 105:
#line 410 "asm32.y"
{ ca_4(yyvsp[-1].value,yyvsp[-5].value,yyvsp[-3].value); ;
    break;}
case 106:
#line 411 "asm32.y"
{ ca_4(yyvsp[-1].value,yyvsp[-5].value,-yyvsp[-3].value); ;
    break;}
case 107:
#line 412 "asm32.y"
{ ca_8(7,yyvsp[-1].value,yyvsp[-3].value); ;
    break;}
case 108:
#line 413 "asm32.y"
{define_data(0x8C000000L|(yyvsp[-2].value<<16)|(yyvsp[0].value&0x7FFL),4); ;
    break;}
case 109:
#line 414 "asm32.y"
{define_data(0x8C200000L|(yyvsp[-2].value<<16)|(yyvsp[0].value&0x1FL),4); ;
    break;}
case 110:
#line 415 "asm32.y"
{ define_data(goto_dest(yyvsp[-1].value,0L),4); ;
    break;}
case 111:
#line 418 "asm32.y"
{ yyval.value = goto_dest(yyvsp[0].value,0L); ;
    break;}
case 112:
#line 419 "asm32.y"
{ yyval.value = goto_dest(yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 113:
#line 420 "asm32.y"
{ yyval.value = goto_dest(yyvsp[-2].value,-yyvsp[0].value); ;
    break;}
case 114:
#line 421 "asm32.y"
{ yyval.value = goto_dest(yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 115:
#line 422 "asm32.y"
{ yyval.value = goto_dest(yyvsp[-2].value,-yyvsp[0].value); ;
    break;}
case 116:
#line 423 "asm32.y"
{ yyval.value = goto_dest(0,yyvsp[0].value); ;
    break;}
case 117:
#line 426 "asm32.y"
{ ca_8(5,yyvsp[0].value,0L); ;
    break;}
case 118:
#line 427 "asm32.y"
{ ca_8(5,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 119:
#line 428 "asm32.y"
{ ca_8(5,yyvsp[-2].value,-yyvsp[0].value); ;
    break;}
case 120:
#line 429 "asm32.y"
{ ca_8(5,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 121:
#line 430 "asm32.y"
{ ca_8(5,yyvsp[-2].value,-yyvsp[0].value); ;
    break;}
case 122:
#line 431 "asm32.y"
{ ca_8(5,0,yyvsp[0].value); ;
    break;}
case 127:
#line 440 "asm32.y"
{ define_data(yyvsp[0].value,4); ;
    break;}
case 128:
#line 441 "asm32.y"
{ ; ;
    break;}
case 129:
#line 442 "asm32.y"
{ define_data(yyvsp[0].value|(yyvsp[-2].value<<12)|0x400L,4); ;
    break;}
case 130:
#line 444 "asm32.y"
{ long v = ca_6a(0,yyvsp[-4].value,23,yyvsp[-2].value);
						  define_data(v|(yyvsp[-6].value<<12)|0x400L,4); ;
    break;}
case 131:
#line 447 "asm32.y"
{ long v = ca_6a(0,yyvsp[-4].value,22,yyvsp[-2].value);
						  define_data(v|(yyvsp[-6].value<<12)|0x400L,4); ;
    break;}
case 132:
#line 452 "asm32.y"
{ yyval.value = ca_6a(0,yyvsp[-4].value,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 133:
#line 454 "asm32.y"
{ yyval.value = ca_6a(2,yyvsp[-4].value,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 134:
#line 456 "asm32.y"
{ yyval.value = ca_6a(7,yyvsp[-2].value,yyvsp[0].value,0); ;
    break;}
case 135:
#line 458 "asm32.y"
{ yyval.value = ca_6a(14,yyvsp[-4].value,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 136:
#line 460 "asm32.y"
{ yyval.value = ca_6a(15,yyvsp[-2].value,yyvsp[0].value,0); ;
    break;}
case 137:
#line 462 "asm32.y"
{ yyval.value = ca_6a(10,yyvsp[-4].value,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 138:
#line 464 "asm32.y"
{ yyval.value = ca_6a(8,yyvsp[-4].value,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 139:
#line 466 "asm32.y"
{ yyval.value = ca_6a(13,yyvsp[-4].value,yyvsp[-2].value,0); ;
    break;}
case 140:
#line 468 "asm32.y"
{ yyval.value = ca_6a(12,yyvsp[-4].value,yyvsp[-2].value,0); ;
    break;}
case 141:
#line 470 "asm32.y"
{ yyval.value = ca_6a(9,yyvsp[-4].value,yyvsp[-2].value,0); ;
    break;}
case 142:
#line 472 "asm32.y"
{ yyval.value = ca_6a(11,yyvsp[-4].value,yyvsp[-2].value,0); ;
    break;}
case 143:
#line 474 "asm32.y"
{ yyval.value = ca_6a(5,yyvsp[-3].value,yyvsp[0].value,0); ;
    break;}
case 144:
#line 476 "asm32.y"
{ yyval.value = ca_6a(1,yyvsp[-4].value,yyvsp[-2].value,0); ;
    break;}
case 145:
#line 478 "asm32.y"
{ yyval.value = ca_6a(3,yyvsp[-4].value,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 146:
#line 480 "asm32.y"
{ yyval.value = ca_6a(6,yyvsp[-5].value,yyvsp[-3].value,yyvsp[0].value); ;
    break;}
case 147:
#line 482 "asm32.y"
{ yyval.value = ca_6a(10,yyvsp[-2].value,yyvsp[0].value,yyvsp[0].value); ;
    break;}
case 148:
#line 485 "asm32.y"
{ ca_5(yyvsp[-4].value,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 149:
#line 486 "asm32.y"
{ ca_5(yyvsp[-4].value,yyvsp[-2].value,-yyvsp[0].value); ;
    break;}
case 150:
#line 487 "asm32.y"
{ ca_6c(7,yyvsp[-2].value,yyvsp[0].value,0L); ;
    break;}
case 151:
#line 488 "asm32.y"
{ ca_6c(2,yyvsp[-4].value,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 152:
#line 489 "asm32.y"
{ ca_6c(14,yyvsp[-4].value,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 153:
#line 490 "asm32.y"
{ ca_6c(15,yyvsp[-2].value,yyvsp[0].value,0L); ;
    break;}
case 154:
#line 491 "asm32.y"
{ ca_6c(10,yyvsp[-4].value,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 155:
#line 492 "asm32.y"
{ ca_6c(8,yyvsp[-4].value,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 156:
#line 493 "asm32.y"
{ ca_6c(3,yyvsp[-4].value,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 157:
#line 496 "asm32.y"
{ if((yyvsp[-2].value&EXT) == 0) ca_5(yyvsp[-2].value,0,yyvsp[0].value);
						else ca_8(6,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 158:
#line 498 "asm32.y"
{ ca_7b(0,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 159:
#line 499 "asm32.y"
{ ca_7b(0,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 160:
#line 500 "asm32.y"
{ ca_7b(0,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 161:
#line 501 "asm32.y"
{ ca_7b(1,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 162:
#line 502 "asm32.y"
{ ca_7a(0,yyvsp[-3].value,yyvsp[0].value); ;
    break;}
case 163:
#line 503 "asm32.y"
{ define_data(0x17600000L|(yyvsp[0].value&0x1FFFFFL),4); ;
    break;}
case 164:
#line 504 "asm32.y"
{ define_data(0x17400000L|((yyvsp[0].value&0x1FL)<<16),4); ;
    break;}
case 165:
#line 505 "asm32.y"
{ ca_7a(1,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 166:
#line 506 "asm32.y"
{ ca_7a(1,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 167:
#line 507 "asm32.y"
{ ca_7b(1,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 168:
#line 508 "asm32.y"
{ ca_7b(1,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 169:
#line 509 "asm32.y"
{ ca_7b(1,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 170:
#line 510 "asm32.y"
{ ca_7b(1,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 171:
#line 511 "asm32.y"
{ ca_7d(1,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 172:
#line 512 "asm32.y"
{ ca_7d(1,yyvsp[0].value,yyvsp[-2].value); ;
    break;}
case 173:
#line 513 "asm32.y"
{ ca_7d(0,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 174:
#line 514 "asm32.y"
{ ca_7d(0,yyvsp[-2].value,yyvsp[0].value); ;
    break;}
case 181:
#line 525 "asm32.y"
{ if(yyvsp[0].value == UNDEFINED) warn_symbol("Undefined Symbol",Last_symbol); ;
    break;}
case 182:
#line 526 "asm32.y"
{ if(yyvsp[0].value == UNDEFINED) error_symbol("Undefined Label",Last_symbol); ;
    break;}
case 184:
#line 528 "asm32.y"
{ yyval.value = yyvsp[-1].value; ;
    break;}
case 185:
#line 529 "asm32.y"
{ yyval.value = (yyvsp[-4].value ? yyvsp[-2].value : yyvsp[0].value); if(yyvsp[-4].value==UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 186:
#line 530 "asm32.y"
{ yyval.value = yyvsp[-2].value | yyvsp[0].value;    if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 187:
#line 531 "asm32.y"
{ yyval.value = yyvsp[-2].value ^ yyvsp[0].value;    if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 188:
#line 532 "asm32.y"
{ yyval.value = yyvsp[-2].value & yyvsp[0].value;    if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 189:
#line 533 "asm32.y"
{ yyval.value = yyvsp[-2].value == yyvsp[0].value;   if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 190:
#line 534 "asm32.y"
{ yyval.value = yyvsp[-2].value != yyvsp[0].value;   if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 191:
#line 535 "asm32.y"
{ yyval.value = yyvsp[-2].value < yyvsp[0].value;    if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 192:
#line 536 "asm32.y"
{ yyval.value = yyvsp[-2].value > yyvsp[0].value;    if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 193:
#line 537 "asm32.y"
{ yyval.value = yyvsp[-2].value <= yyvsp[0].value;   if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 194:
#line 538 "asm32.y"
{ yyval.value = yyvsp[-2].value >= yyvsp[0].value;   if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 195:
#line 539 "asm32.y"
{ yyval.value = yyvsp[-2].value << yyvsp[0].value;   if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 196:
#line 540 "asm32.y"
{ yyval.value = yyvsp[-2].value >> yyvsp[0].value;   if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 197:
#line 541 "asm32.y"
{ yyval.value = yyvsp[-2].value + yyvsp[0].value;    if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 198:
#line 542 "asm32.y"
{ yyval.value = yyvsp[-2].value - yyvsp[0].value;    if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 199:
#line 543 "asm32.y"
{ yyval.value = yyvsp[-2].value * yyvsp[0].value;    if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 200:
#line 544 "asm32.y"
{ if(yyvsp[0].value != 0L) yyval.value = yyvsp[-2].value / yyvsp[0].value;
					  else yyval.value = UNDEFINED;
					  if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 201:
#line 547 "asm32.y"
{ if(yyvsp[0].value != 0L) yyval.value = yyvsp[-2].value % yyvsp[0].value;
					  else yyval.value = UNDEFINED;
					  if(yyvsp[-2].value == UNDEFINED || yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 202:
#line 550 "asm32.y"
{ yyval.value = ! yyvsp[0].value;       if(yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 203:
#line 551 "asm32.y"
{ yyval.value = ~ yyvsp[0].value;       if(yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
case 204:
#line 552 "asm32.y"
{ yyval.value = - yyvsp[0].value;       if(yyvsp[0].value == UNDEFINED) yyval.value = UNDEFINED; ;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 465 "/usr/local/lib/bison.simple"

  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YYLSP_NEEDED
  yylsp -= yylen;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column = yylloc.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  goto yynewstate;

yyerrlab:   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      yyerror(msg);
	      free(msg);
	    }
	  else
	    yyerror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YYERROR_VERBOSE */
	yyerror("parse error");
    }

  goto yyerrlab1;
yyerrlab1:   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (yychar == YYEOF)
	YYABORT;

#if YYDEBUG != 0
      if (yydebug)
	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
#endif

      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  goto yyerrhandle;

yyerrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) goto yydefault;
#endif

yyerrpop:   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YYLSP_NEEDED
  yylsp--;
#endif

#if YYDEBUG != 0
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    goto yyerrdefault;

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    goto yyerrdefault;

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;

  if (yyn == YYFINAL)
    YYACCEPT;

#if YYDEBUG != 0
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = yylval;
#ifdef YYLSP_NEEDED
  *++yylsp = yylloc;
#endif

  yystate = yyn;
  goto yynewstate;
}
#line 560 "asm32.y"


/* stuff for listing */
int Line_on_page = 9999;
int Page_number = 0;
char Title[82] = "ASM32 - DSP32C Assembler     ";
/* List[] contains line to be listed */
char List[257] = "";
#define ADDR_COL	7	/* Col # for address in List[] */
#define DATA_COL	14	/* Col # for 4 data bytes in List[] */
#define SOURCE_COL	26	/* Col # for source line in List[] */
FILE *List_file = 0;            /* List output file */
FILE *List_in = 0;		/* original input file for listing */
char Input2[257] = "";		/* second ary input buffer for listing */
int List_line = 0;		/* line # on secondary input file */
int Block_comment = 0;		/* flag for block comments */

/* Input[] contains input line, Index points to next char */
char Input[257] = "";
int Index = 0;
char Filename[65] = "";
char Main_filename[65] = "";
FILE *Input_file = 0;
int Line_number = 0;

/* Data[] for program */
unsigned char *Data = 0;

/* Misc control variables */
int Pass = 1;
int Dsp_handle = -1;
int Errors = 0;
int Warnings = 0;
int D_flag = 0;

void main(int argc, char *argv[])
{
	struct stat stat_struct;
	int i;
	char file[MAXFILE],ext[MAXEXT];
	char buf[80];
	unsigned char c;

	if(argc >= 2 && strcmp(argv[1],"-d") == 0) {
		D_flag = 1;
		--argc, ++argv;
	}

	if(argc < 2 || argc > 3 || strlen(argv[1]) >= sizeof(Filename)-1)
	    fatal("No Input File/Illegal Filename/Illegal # of Parameters");

	atexit(endit);

	/* split up the filename */
	strcpy(Filename,argv[1]);
	strcpy(Main_filename,Filename);
	fnsplit(Filename,(char *)0,(char *)0,file,ext);

	/* open input file */
	if(argc == 3) {
		List_in = fopen(Main_filename,"r");
		List_line = 0;
		strcpy(Filename,argv[2]);
	}
	Input_file = fopen(Filename,"r");
	if(!Input_file) {
	    fprintf(stderr,"asm32: Cannot Open '%s'\n",Filename);
	    exit(1);
	}

	/* get Dsp_handle filename and List_file filename */
	strcpy(buf,file);
	strcat(buf,".lst");
	List_file = fopen(buf,"w"); // ignore failure for List_file
	strcpy(buf,file);
	if(D_flag) {
		strcat(buf,".dat");
		Dsp_handle = open(buf,O_WRONLY|O_CREAT|O_TRUNC,0666);
	} else {
		strcat(buf,".dsp");
		Dsp_handle = open(buf,O_WRONLY|O_CREAT|O_TRUNC|O_BINARY,0666);
	}
	if(Dsp_handle < 0) {
		fprintf(stderr,"asm32: Cannot Create/Write DSP-file '%s'\n",buf);
		exit(3);
	}

	/* get Title[] */
	if(stat(Filename,&stat_struct)) {
		strftime(buf,sizeof(buf),"%m/%d/%y %H:%M     ",
					localtime(&stat_struct.st_mtime));
		strcat(Title,buf);
	}
	strcat(Title,file);
	strcat(Title,ext);
	while(strlen(Title) < 72)
		strcat(Title," ");
	if(strlen(Title) == 72)
		strcat(Title,"Page");

	/* initialize the assembler */
	Errors = 0;
	Warnings = 0;
	symbol_init();
	Data = malloc(MAX_DATA);
	if(!Data)
		fatal("Out of Memory");
	memset(Data,0,MAX_DATA);

	/* pass 1 */
	Pass = 1;
	Line_number = 0;
	Org = 0L;
	Input[0] = '\0';
	Index = 0;
	yyparse();

	/* pass 2 */
	Pass = 2;
	Line_number = 0;
	Org = 0L;
	Input[0] = '\0';
	Index = 0;
	rewind(Input_file);
	undefine_symbols(SYMBOL);
	yyparse();

	if(Errors > 0 || Warnings > 0) {
		sprintf(buf,"%d Warnings, %d Errors",Warnings,Errors);
		fprintf(List_file,"asm32: %s\n",buf);
		if(Errors > 0)
			fatal(buf);
		fprintf(stderr,"asm32: %s\n",buf);
	}	

	if(Org > MAX_DATA)
		fatal("Program Too Large");

	/* output assembled program */
	if(D_flag) {
		for(i=0; i<Org; ++i) {
			c = Data[i];
			if(c >= 100) {
				buf[0] = c/100 + '0';
				c = c % 100;
			} else {
				buf[0] = ' ';
			}
			if(c >= 10) {
				buf[1] = c/10 + '0';
				c = c % 10;
			} else {
				buf[1] = (buf[0]==' ') ? ' ' : '0';
			}
			buf[2] = c + '0';
			buf[3] = ',';
			if(write(Dsp_handle,buf,4) != 4)
				fatal("Write Error on DSP file!");
			if((i&15) == 15)
				write(Dsp_handle,"\n",1);
		}
	} else {
		if(write(Dsp_handle,Data,(int)Org) != (int)Org)
			fatal("Write Error on DSP file!");
	}
	
	/* done */
	exit(0);
}

void endit(void)
{
	close(Dsp_handle);

	fputs("\f",List_file);
	fclose(List_file);
}

#pragma argsused
void yyerror(char *s)
{
}

void errormsg(char *s)
{
	if(Pass != 2)
		return;
	list_print();
	if(++Line_on_page > Page_length)
		list_page(0);
	fprintf(List_file,"asm32 Error: %s in '%s' Line %d\n",
						s,Filename,Line_number);
	fprintf(stderr,"asm32 Error: %s in '%s' Line %d\n",
						s,Filename,Line_number);
	if(++Errors >= 25)
		fatal("Too Many Errors");
}

void error_symbol(char *msg, Symbol *s)
{
	char buf[99];
	sprintf(buf,"%s '%s'",msg,s->name);
	errormsg(buf);
}

void warning(char *s)
{
	if(Pass != 2)
		return;
	list_print();
	if(++Line_on_page > Page_length)
		list_page(0);
	fprintf(List_file,"asm32 Warning: %s in '%s' Line %d\n",
						s,Filename,Line_number);
	fprintf(stderr,"asm32 Warning: %s in '%s' Line %d\n",
						s,Filename,Line_number);
	++Warnings;
}

void warn_symbol(char *msg, Symbol *s)
{
	char buf[99];
	sprintf(buf,"%s '%s'",msg,s->name);
	warning(buf);
}

void fatal(char *s)
{
	fprintf(List_file,"asm32 Fatal: %s in '%s' Line %d\n",
						s,Filename,Line_number);
	fprintf(stderr,"asm32 Fatal: %s in '%s' Line %d\n",
						s,Filename,Line_number);
	exit(1);
}

int yylex()
{
	int i,j, c,d, radix, type;
	Symbol *s;
	char name[40];
#define isalnum_(c) (isalnum(c) || c == '_')

	yylval.value = UNDEFINED;
again:
	c = getinput();
	if(c == EOF) {
		type = 0;
	} else if(isdigit(c)) {
		name[0] = c;
		j = 1;
		if(c == '0' && toupper(Input[Index]) == 'X') {
			name[j++] = Input[Index++];
			while(isxdigit(Input[Index]))
				name[j++] = Input[Index++];
		} else {
			while(isdigit(Input[Index]))
				name[j++] = Input[Index++];
		}
		if(Input[Index] == '.') {	/* floating-point constant */
			name[j++] = Input[Index++];
			while(isdigit(Input[Index]))
				name[j++] = Input[Index++];
			if(toupper(Input[Index]) == 'E') {
				name[j++] = Input[Index++];
				if(Input[Index] == '+' || Input[Index] == '-')
					name[j++] = Input[Index++];
				while(isdigit(Input[Index]))
					name[j++] = Input[Index++];
			}
			name[j] = '\0';
			yylval.value = dspfloat(atof(name));
			type = FCONST;
		} else {			/* integer constant */
			name[j] = '\0';
			yylval.value = strtol(name,0,0);
			if(yylval.value == 1L)
				type = CONST1;
			else if(yylval.value == 2L)
				type = CONST2;
			else
				type = CONST;
		}
	} else if(isalnum_(c)) {
		name[0] = c;
		i = 1;
		while(isalnum_(Input[Index]) && i<MAX_SYMBOL)
			name[i++] = Input[Index++];
		name[i] = '\0';
		s = symbol(name);
		yylval.value = s->value;
		type = s->type;
	} else switch(c) {
	case '\n':
		type = c;
		break;
	case '/':
		c = Input[Index];
		if(c == '/') {
			Input[Index] = '\0';
			type = '\n';
			break;
		} else if(c == '*') {
			do {
				while(getinput() != '*')
					;
			} while(getinput() != '/');
			goto again;
		}
		type = '/';
		break;
	case '+':
		if(Input[Index] == '+') {
			++Index;
			type = PLSPLS;
			break;
		}
		type = '+';
		break;
	case '-':
		if(Input[Index] == '-') {
			++Index;
			type = MINUSMINUS;
			break;
		}
		type = '-';
		break;
	case '=':
		if(Input[Index] == '=') {
			++Index;
			type = EQUEQU;
			break;
		}
		type = '=';
		break;
	case '!':
		if(Input[Index] == '=') {
			++Index;
			type = NOTEQU;
			break;
		}
		type =  '!';
		break;
	case '<':
		if(Input[Index] == '=') {
			++Index;
			type = LE;
			break;
		}
		if(Input[Index] == '<') {
			if(Input[Index+1] == '<') {
				Index += 2;
				type = LROTATE;
				break;
			}
			++Index;
			type = LSHIFT;
			break;
		}
		type = '<';
		break;
	case '>':
		if(Input[Index] == '=') {
			++Index;
			type = GE;
			break;
		}
		if(Input[Index] == '>') {
			if(Input[Index+1] == '>') {
				Index += 2;
				type = RROTATE;
				break;
			}
			++Index;
			type = RSHIFT;
			break;
		}
		type =  '>';
		break;
	case '$':
		yylval.value = Org;
		type = CONST;
		break;
	default:
		if(isspace(c))
			goto again;
		type = c;
	}
done:
	return type;
}

int getinput()
{
	int i;

	while(Input[Index] == '\0') {
		list_print();
		Index = 0;
		++Line_number;
		for(;;) {
			if(!fgets(Input,sizeof(Input),Input_file)) {
				Input[0] = '\0';
				return EOF;
			}
			if(strncmp(Input,"#line",5) == 0) {
				char *p;
				if(Pass == 2) {
					--Line_number;
					prepare_list();
					++Line_number;
				}
				i = strtol(Input+6,&p,10);
				while(*p != '\0' && isspace(*p))
					++p;
				if(Pass == 2 && strncmp(Filename,p,strlen(Filename)) != 0
					     && strcmp(Filename,Main_filename) == 0) {
					prepare_list();
					list_print(); // print the #include
				}
				Line_number = i;
				if(*p) {
					for(i=0; i<sizeof(Filename)-1; ++i) {
						if(*p == '\0' || isspace(*p))
							break;
						Filename[i] = *p++;
					}
					Filename[i] = '\0';
				}
			} else {
				break;
			}
		}
		if(Pass == 2)
			prepare_list();
	}

	return Input[Index++];
}

/*	dspfloat() converts an 8087 float to a DSP32C float,
	which is returned as a long value.	*/
long dspfloat(float f)
{
	int neg = 0;
	long m,e;
	union {long l; float f;} u;

	if(f < 0.0) {
		f = -f;
		neg = 1;
	}
	u.f = f;

	m = u.l & 0x007FFFFFL;
	e = (u.l >> 23) & 0x000000FFL;

	if(e != 0)
		e += 1;
	else
		m = 0L; // unnormalized underflows ==> 0.0
	if(e > 0xFF) {
		e = 0xFF;
		m = 0x007FFFFFL;
	}
	m = (m<<8) | e;

	return neg ? dspnegfloat(m) : m;
}

/*	dspnegfloat() converts a positive DSP32C float to a
	negative one. Both are passed as longs.	*/
long dspnegfloat(long f)
{
	long m,e;

	if(f == 0L)
		return f;

	m = f >> 8;
	e = f & 0xFFL;

	m = -m;
	if(f > 0L && m == 0L)
		e -= 1, m = 0x00800000L;
	else if(f < 0L && m == 0L)
		e += 1;

	return (m<<8) | e;
}

void list_address(long addr)
{
	char buf[10];

	if(Pass != 2 || List[0] == '\0')
		return;
	sprintf(buf,"%06lX:",addr);
	memcpy(List+ADDR_COL-1,buf,7);
}

void list_data(long data, int offset, int size)
{
	char buf[24];
	int more = 0;
	int i,j,n;
	static long mask[5] = {0,0xFFL,0xFFFFL,0xFFFFFFL,0xFFFFFFFFL};

	if(Pass != 2)
		return;
	if(size < 0) {
		size = -size;
		more = 3;
	}

	if(List[0] == '\0') {
		memset(List,' ',SOURCE_COL);
		List[SOURCE_COL-1] = '\n';
		List[SOURCE_COL] = '\0';
	}
	if(offset == 0)
		list_address(Org);
	sprintf(buf,"%0*lX...",size+size,data&mask[size]);
	n = size+size+more;
	for(i=0, j=DATA_COL-1+offset*3; i<n; ++i,++j) {
		if(List[j] != ' ')
			break;
		List[j] = buf[i];
	}
	if(offset+size >= 4)
		list_print();
}

void prepare_list()
{
	if(List_in && strcmp(Filename,Main_filename)==0 && List_line < Line_number) {
		while(List_line < Line_number) {
			if(List[0])
				list_print();
			if(!fgets(Input2,sizeof(Input2),List_in)) {
				List_in = 0;
				break;
			}
			prepare_list_line(++List_line,Input2,' ');
		}
	} else {
		prepare_list_line(Line_number,Input,'X');
	}
}

void prepare_list_line(int lineno, char *input, char flag)
{
	int i,j;

	if(strncmp(input,"#line",5) == 0) {
		List[0] = '\0';
		return;
	}

	if(strcmp(Filename,Main_filename) != 0)
		flag = 'I';

	sprintf(List,"%4d%c",lineno,flag);
	memset(List+5,' ',SOURCE_COL-1);

	if(Block_comment || (input[0] == '/' && input[1] == '*')) {
		i = ADDR_COL - 1;
		Block_comment = 1;
	} else {
		i = SOURCE_COL-1;
	}

	for(j=0; input[j]; ++j) {
		if(i >= sizeof(List)-2)
			break;
		if(input[j] == '\t') {
			do {
				List[i++] = ' ';
			} while(((i-SOURCE_COL)&7) != 7);
		} else {
			List[i++] = input[j];
		}
	}
	List[i] = '\0';

	for(j=0; input[j]; ++j) {
		if(input[j] == '*' && input[j+1] == '/') {
			Block_comment = 0;
			break;
		}
	}
}

void list_print()
{
	if(Pass != 2 || List[0] == '\0')
		return;
	if(((List_type&1)!=0 && strcmp(Filename,Main_filename) == 0) ||
	   ((List_type&2)!=0 && List[DATA_COL] != ' ' && !Block_comment) ||
	   ((List_type&4)!=0) ){
		if(++Line_on_page > Page_length)
			list_page(0);
		if(strlen(List) >= Page_width) {
			List[Page_width-1] = '\n';
			List[Page_width] = '\0';
		}
		fputs(List,List_file);
	}
	List[0] = '\0';
}

void list_page(int omit_list)
{
	if(Pass != 2)
		return;

	if(++Page_number > 1)
		fputc('\f',List_file);

	fprintf(List_file,"\n\n\n%s%3d\n\n",Title,Page_number);

	Line_on_page = 6;

	if(omit_list)
		List[0] = '\0';
}

void end_stmt()
{
}

void define_data(long value, int size)
{
	int list = 1;

	if(size < 0) {
		list = 0;
		size = -size;
	}

	if(Org%size != 0)
		errormsg("Alignment Error");

	if(Org+size >= MAX_DATA) {
		errormsg("Program Exceeded MAX_DATA in Size");
		Org += size;
	} else {
		if(Pass == 1) {
			Org += size;
		} else {
			if(list)
				list_data(value,(int)Org&3,size);
			if((size==1 && (value > 127L   || value < -128L))  ||
			   (size==2 && (value > 65536L || value < -32768L)))
				warning("Value Exceeds Data Size");
			while(size--) {
				Data[Org++] = value;
				value >>= 8;
			}
		}
	}
}

void define_array(int n, long value, int size)
{
	list_address(Org);
	list_data(value,(int)Org&3,-size);
	while(n-- > 0)
		define_data(value,-size);
}

/*	SYMBOL TABLE ROUTINES	*/

#define N_HASH	128	/* power of 2 */
Symbol *Symbol_table[N_HASH] = {0};

int hash(char *name)
{
	int h;
	
	h = 0;
	while(*name) {
		h = (h << 1) | ((h>>7) & 1);
		h += *name++;
	}
	
	return h & (N_HASH-1);
}

Symbol *symbol(char *name)
{
	Symbol *s;
	int h;
	
	h = hash(name);
	for(s=Symbol_table[h]; s; s=s->next) {
		if(strncmp(name,s->name,sizeof(s->name)) == 0) {
			if(s->type == SYMBOL || s->type == LABEL)
				Last_symbol = s;
			return s;
		}
	}

	/* create a new Symbol entry */
	s = (Symbol *)malloc(sizeof(Symbol));
	if(!s)
		fatal("Out of Memory");
	s->next = Symbol_table[h];
	Symbol_table[h] = s;
	strncpy(s->name,name,sizeof(s->name));
	s->type = SYMBOL;
	s->value = UNDEFINED;
	Last_symbol = s;
	return s;
}

void define_label(long value)
{
	if(!Symbol_def) {
		errormsg("Undefined Symbol");
		return;
	}
	
	if(Pass == 1) {
		if(Symbol_def->type == SYMBOL) {
			Symbol_def->type = LABEL;
			Symbol_def->value = value;
		}
	} else {
		if(Symbol_def->value != value)
			error_symbol("Phase Error or Redefinition of",
								Symbol_def);
		else if(value == UNDEFINED)
			error_symbol("Undefined value in",Symbol_def);
	}
	
	list_address(Symbol_def->value);
}

void define_symbol(long value)
{
	char buf[80];

	if(!Symbol_def) {
		errormsg("Undefined Symbol");
		return;
	}

	if(Symbol_def->type != SYMBOL) {
		error_symbol("Attempt to re-define Reserved Word or Label",
						Symbol_def);
	} else {
		Symbol_def->value = value;
		if(List[0] != '\0') {
			sprintf(buf,"%08lx",value);
			memcpy(List+ADDR_COL-1,buf,8);
		}
	}
}

void symbol_init()
{
	int i,j, h;
	char buf[16];
	Symbol *s;
	static Symbol reserved[] = {
		{0,"a0",ACCUM,0L},	/* accumulators */
		{0,"a1",ACCUM,1L},
		{0,"a2",ACCUM,2L},
		{0,"a3",ACCUM,3L},
		{0,"ibuf",IBUF,4L},	/* other data registers */
		{0,"ibufe",IBUF,4L|EXT},
		{0,"ibufl",IBUF,4L|LOW},
		{0,"obuf",OBUF,5L},
		{0,"obufe",OBUF,5L|EXT},
		{0,"obufl",OBUF,5L|LOW},
		{0,"pdr",PDR,6L},
		{0,"pdre",PDR,6L|EXT},
		{0,"pdr2",PDR,20L},
		{0,"pc",PC,15L},
		{0,"pce",PC,15L|EXT},
		{0,"pin",REGIO,24L|EXT},
		{0,"pout",REGIO,25L|EXT},
		{0,"dauc",DAUC,26L},
		{0,"ioc",IOC,27L},
		{0,"ivtp",REGIO,29L|EXT},
		{0,"pcsh",PCSH,30L},
		{0,"pcshe",PCSH,30L|EXT},
		{0,"piop",PIOP,14L|LOW},
		{0,"pir",PIR,22L},
		{0,"pcw",PCW,30L},
		{0,"org",ORG,UNDEFINED}, /* psuedo-ops */
		{0,"end",END,UNDEFINED},
		{0,"align",ALIGN,UNDEFINED},
		{0,"byte",BYTE,UNDEFINED},
		{0,"char",BYTE,UNDEFINED},
		{0,"word",INT,UNDEFINED},
		{0,"long",INT24,UNDEFINED},
		{0,"page",PAGE,UNDEFINED},
		{0,"list",LIST,UNDEFINED},
		{0,"equ",EQU,UNDEFINED},
		{0,"ic",DA_FUN,0L},	/* DA special instructions */
		{0,"oc",DA_FUN,1L},
		{0,"float",FLOAT,2L},
		{0,"int",INT,3L},
		{0,"round",DA_FUN,4L},
		{0,"ifalt",DA_FUN,5L},
		{0,"ifaeq",DA_FUN,6L},
		{0,"ifagt",DA_FUN,7L},
		{0,"float24",DA_FUN,10},
		{0,"int24",INT24,11},
		{0,"ieee",DA_FUN,12},
		{0,"dsp",DA_FUN,13},
		{0,"seed",DA_FUN,14},
		{0,"if",IF,UNDEFINED},	/* CA Special instructions */
		{0,"goto",GOTO,UNDEFINED},
		{0,"call",CALL,UNDEFINED},
		{0,"return",RETURN,UNDEFINED},
		{0,"ireturn",IRETURN,UNDEFINED},
		{0,"do",DO,UNDEFINED},
		{0,"nop",NOP,UNDEFINED},
		{0,"pl",CA_COND,2},		/* CA conditions */
		{0,"mi",CA_COND,3},
		{0,"ne",CA_COND,4},
		{0,"eq",CA_COND,5},
		{0,"vc",CA_COND,6},
		{0,"vs",CA_COND,7},
		{0,"cc",CA_COND,8},
		{0,"cs",CA_COND,9},
		{0,"ge",CA_COND,10},
		{0,"lt",CA_COND,11},
		{0,"gt",CA_COND,12},
		{0,"le",CA_COND,13},
		{0,"hi",CA_COND,14},
		{0,"ls",CA_COND,15},
		{0,"ane",DA_COND,20},		/* DA conditions */
		{0,"aeq",DA_COND,21},
		{0,"age",DA_COND,18},
		{0,"alt",DA_COND,19},
		{0,"avc",DA_COND,22},
		{0,"avs",DA_COND,23},
		{0,"auc",DA_COND,16},
		{0,"aus",DA_COND,17},
		{0,"agt",DA_COND,24},
		{0,"ale",DA_COND,25},
		{0,"ibe",IO_COND,32},		/* I/O conditions */
		{0,"ibf",IO_COND,33},
		{0,"obe",IO_COND,35},
		{0,"obf",IO_COND,34},
		{0,"pde",IO_COND,36},
		{0,"pdf",IO_COND,37},
		{0,"pie",IO_COND,38},
		{0,"pif",IO_COND,39},
		{0,"syc",IO_COND,40},
		{0,"sys",IO_COND,41},
		{0,"fbc",IO_COND,42},
		{0,"fbs",IO_COND,43},
		{0,"ireq1_hi",IO_COND,45},
		{0,"ireq1_lo",IO_COND,44},
		{0,"ireq2_hi",IO_COND,46},
		{0,"ireq2_lo",IO_COND,47},
	};

	for(i=0; i<N_HASH; ++i)
		Symbol_table[i] = (Symbol *)0;

	for(i=0; i<sizeof(reserved)/sizeof(reserved[0]); ++i) {
		h = hash(reserved[i].name);
		reserved[i].next = Symbol_table[h];
		Symbol_table[h] = &reserved[i];
	}
	
	/* add registers */
	for(i=1; i<=22; ++i) {
		if(i <= 14)
			j = i;
		else if(i <= 19)
			j = i + 2;
		else if(i <= 21)
			j = i + 4;
		else
			j = 29;
		sprintf(buf,"r%d",i);
		s = symbol(buf);
		s->type = REG;
		s->value = j;
		sprintf(buf,"r%dr",i);
		s = symbol(buf);
		s->type = REGR;
		s->value = j | REV;
		sprintf(buf,"r%de",i);
		s = symbol(buf);
		s->type = REGE;
		s->value = j | EXT;
		sprintf(buf,"r%dl",i);
		s = symbol(buf);
		s->type = REGHL;
		s->value = j | LOW;
		sprintf(buf,"r%dh",i);
		s = symbol(buf);
		s->type = REGHL;
		s->value = j | HIGH;
	}	
}

void undefine_symbols(int type)
{
	int i;
	Symbol *s;

	for(i=0; i<N_HASH; ++i) {
		for(s=Symbol_table[i]; s; s=s->next) {
			if(s->type == type)
				s->value = UNDEFINED;
		}
	}
}

/*	mem_ref() - prepare a memory-reference via regs
	result is for CA format 7b (or 7d), r,P,I fields
	NO VALIDITY CHECKS ARE PERFORMED!
*/
long mem_ref(long reg, long incr)
{
	long v = ((reg&0x1FL)<<5) | (incr&0x1FL);
	if((incr&REV) != 0)
		v |= (1<<10);
	return v;
}

/*	x_ref() converts a mem_ref() to X.	*/
long x_ref(long mem_ref)
{
	unsigned int p = (mem_ref>>5) & 0x1FL;
	unsigned int i = mem_ref & 0x1FL;

	if((i >= 16 && i <= 23) || (p == 0 && i <= 4))
		i &= 7;
	else
		i = 99;	
	if((mem_ref&(1L<<10)) != 0)
		errormsg("X-field cannot use bit-reversed increment");

	if((p == 0 && i >= 5) || i > 7 || p >= 15)
		errormsg("Illegal reference in X field");

	return ((long)i << 14) | ((long)p << 17);		
}

/*	y_ref() converts a mem_ref() to Y.	*/
long y_ref(long mem_ref)
{
	unsigned int p = (mem_ref>>5) & 0x1FL;
	unsigned int i = mem_ref & 0x1FL;

	if((i >= 16 && i <= 23) || (p == 0 && (i <= 4 || i == 6)))
		i &= 7;
	else
		i = 99;
	if((mem_ref&(1L<<10)) != 0)
		errormsg("Y-field cannot use bit-reversed increment");

	if((p == 0 && i >= 5 && i != 6) || i > 7 || p >= 15)
		errormsg("Illegal reference in Y field");

	return ((long)i << 7) | ((long)p << 10);		
}

/*	z_ref() converts a mem_ref() to Z.	*/
long z_ref(long mem_ref)
{
	unsigned int p = (mem_ref>>5) & 0x1FL;
	unsigned int i = mem_ref & 0x1FL;
	long r = (mem_ref&(1L<<10)) ? (1L<<25) : 0L;

	if(p != 0) {
		if(i >= 16 && i <= 23)
			i &= 7;
		else if(i != 7)
			i = 99;
	} else {
		if(i <= 4 || i > 7)
			i = 99;
	}
	if(p > 15 || i > 7)
		errormsg("Illegal reference in Z field");

	return (long)i | ((long)p<<3) | r;
}

void da_1(long fmt, long m, long f, long s, long da_dest, long x, long y, long z)
{
	long n,v;
	
	if(z == 7L)
		z = da_dest & 0x7FFL;
	else if((da_dest&0x7FFL) != 7)
		errormsg("Two Z= fields is Illegal");

	n = (da_dest>>21) & 3L;
	v = (fmt<<29) | (m<<26) | (f<<24) | (s<<23) | (n<<21) |
						 x_ref(x) | y_ref(y) | z_ref(z);
	define_data(v,4);
}

void da_5(long g, long da_dest, long y)
{
	long v = 0x78000000L | (g<<23) | (da_dest&(3L<<21)) | y_ref(y) |
							z_ref(da_dest&0x7FF);
	define_data(v,4);							
}

long goto_dest(long reg, long n)
{
	if(n > 65536L || n < -32768L)
		warning("Offset Exceeds Field Width");
	if((reg&~(EXT|0x1FL)) != 0L)
		errormsg("Illegal register in goto");
	return ((reg&0x1FL)<<16) | (n & 0x0000FFFFL);
}

void ca_0(long cond, long goto_dest)
{
	long v = ((cond&0x3FL)<<21) | goto_dest;

        define_data(v,4);
}

void ca_3a(long m, long goto_dest)
{
	long v = 0x0C000000L | ((m&0x1FL)<<21) | goto_dest;

	define_data(v,4);
}

void ca_4(long m, long h, long n)
{
	long v;
	if(n > 65536L || n < -32768L)
		warning("Offset Exceeds Field Width");
	v = 0x10000000L | ((m&0x1FL)<<21) | ((h&0x1FL)<<16) | (n&0x0000FFFFL);
	define_data(v,4);
}

void ca_5(long d, long h, long n)
{
	long v = (d & EXT) | 0x14000000L;

	if(n > 65536L || n < -32768L)
		warning("Offset Exceeds Field Width");
	v |= ((d&0x1FL)<<21) | ((h&0x1FL)<<16) | (n&0x0000FFFFL);
	define_data(v,4);
}

long ca_6a(long f, long d, long s1, long s2)
{
	long v = (d & EXT) | 0x18000000L;

	v |= ((f&0xFL)<<21) | ((d&0x1FL)<<16) | ((s1&0x1FL)<<5) | (s2&0x1FL);
	if(s2 != 0)
		v |= 0x00000800L;	/* E */
	return v;
}

void ca_6c(long f, long d, long n, long s)
{
	long v = (d & EXT) | 0x1A000000L;

	if(s != 0L && s != d)
		errormsg("Illegal 3-operand Instruction with Constant");
	if(n > 65536L || n < -32768L)
		warning("Offset Exceeds Field Width");
	v |= ((f&0xfL)<<21) | ((d&0x1FL)<<16) | (n&0x0000FFFFL);
	define_data(v,4);
}

void ca_7a(long t, long h, long n)
{
	long v = 0x1C000000L;

	if(n > 65536L || n < -32768L)
		warning("Offset Exceeds Field Width");
	v |= (t<<24) | ((h&0x1FL)<<16) | (n&0x0000FFFFL);
	if((h&EXT) != 0)
		v |= 3L<<22;
	else if((h&LOW) != 0)
		v |= 1L<<22;
	else if((h&HIGH) != 0)
		v |= 0L<<22;
	else
		v |= 2L<<22;
	define_data(v,4);
}

void ca_7b(long t, long h, long mem_ref)
{
	long v = 0x1E000000L | (t<<24) | ((h&0x1FL)<<16) | (mem_ref&0x7FFL);
	if((mem_ref&0x3E0L) != 0L)
		v |= (1L<<21);     /* NOT I/O instr */
	else if((h&EXT) != (mem_ref&EXT) ||
				!!(h&(LOW|HIGH)) != !!(mem_ref&(LOW|HIGH)))
		errormsg("Inconsistent Size in I/O Instruction");
	if((h&EXT) != 0)
		v |= 3L<<22;
	else if((h&LOW) != 0)
		v |= 1L<<22;
	else if((h&HIGH) != 0)
		v |= 0L<<22;
	else
		v |= 2L<<22;
	define_data(v,4);
}

void ca_7d(long t, long r, long mem_ref)
{
	long v = 0x1C200000L | (t<<24) | ((r&0x1FL)<<16) | (mem_ref&0x7FFL);
	if((r&EXT) != 0)
		v |= 3L<<22;
	else if((r&LOW) != 0)
		v |= 1L<<22;
	else if((r&HIGH) != 0)
		v |= 0L<<22;
	else
		v |= 2L<<22;
	define_data(v,4);
}

void ca_8(int type, long reg, long expr)
{
	long v;

	reg &= 0x0000001FL;  /* mask off size bits */
	v = ((long)type<<29) | (reg<<16) | ((expr&0x00FF0000L)<<5) |
						(expr&0x0000FFFFL);
        define_data(v,4);
}
